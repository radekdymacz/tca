// Code generated by protoc-gen-go.
// source: joke.proto
// DO NOT EDIT!

package joke

import (
	"reflect"
	"testing"

	client "github.com/micro/go-micro/client"
	server "github.com/micro/go-micro/server"
	context "golang.org/x/net/context"
)

func TestRequest_Reset(t *testing.T) {
	type fields struct {
		FirstName string
		LastName  string
		LimitTo   string
	}
	tests := []struct {
		name   string
		fields fields
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &Request{
				FirstName: tt.fields.FirstName,
				LastName:  tt.fields.LastName,
				LimitTo:   tt.fields.LimitTo,
			}
			m.Reset()
		})
	}
}

func TestRequest_String(t *testing.T) {
	type fields struct {
		FirstName string
		LastName  string
		LimitTo   string
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &Request{
				FirstName: tt.fields.FirstName,
				LastName:  tt.fields.LastName,
				LimitTo:   tt.fields.LimitTo,
			}
			if got := m.String(); got != tt.want {
				t.Errorf("Request.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRequest_ProtoMessage(t *testing.T) {
	type fields struct {
		FirstName string
		LastName  string
		LimitTo   string
	}
	tests := []struct {
		name   string
		fields fields
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := &Request{
				FirstName: tt.fields.FirstName,
				LastName:  tt.fields.LastName,
				LimitTo:   tt.fields.LimitTo,
			}
			r.ProtoMessage()
		})
	}
}

func TestRequest_Descriptor(t *testing.T) {
	type fields struct {
		FirstName string
		LastName  string
		LimitTo   string
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
		want1  []int
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := &Request{
				FirstName: tt.fields.FirstName,
				LastName:  tt.fields.LastName,
				LimitTo:   tt.fields.LimitTo,
			}
			got, got1 := r.Descriptor()
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Request.Descriptor() got = %v, want %v", got, tt.want)
			}
			if !reflect.DeepEqual(got1, tt.want1) {
				t.Errorf("Request.Descriptor() got1 = %v, want %v", got1, tt.want1)
			}
		})
	}
}

func TestRequest_GetFirstName(t *testing.T) {
	type fields struct {
		FirstName string
		LastName  string
		LimitTo   string
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &Request{
				FirstName: tt.fields.FirstName,
				LastName:  tt.fields.LastName,
				LimitTo:   tt.fields.LimitTo,
			}
			if got := m.GetFirstName(); got != tt.want {
				t.Errorf("Request.GetFirstName() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRequest_GetLastName(t *testing.T) {
	type fields struct {
		FirstName string
		LastName  string
		LimitTo   string
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &Request{
				FirstName: tt.fields.FirstName,
				LastName:  tt.fields.LastName,
				LimitTo:   tt.fields.LimitTo,
			}
			if got := m.GetLastName(); got != tt.want {
				t.Errorf("Request.GetLastName() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRequest_GetLimitTo(t *testing.T) {
	type fields struct {
		FirstName string
		LastName  string
		LimitTo   string
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &Request{
				FirstName: tt.fields.FirstName,
				LastName:  tt.fields.LastName,
				LimitTo:   tt.fields.LimitTo,
			}
			if got := m.GetLimitTo(); got != tt.want {
				t.Errorf("Request.GetLimitTo() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestResponse_Reset(t *testing.T) {
	type fields struct {
		Type  string
		Value *ChuckNorrisJoke
	}
	tests := []struct {
		name   string
		fields fields
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &Response{
				Type:  tt.fields.Type,
				Value: tt.fields.Value,
			}
			m.Reset()
		})
	}
}

func TestResponse_String(t *testing.T) {
	type fields struct {
		Type  string
		Value *ChuckNorrisJoke
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &Response{
				Type:  tt.fields.Type,
				Value: tt.fields.Value,
			}
			if got := m.String(); got != tt.want {
				t.Errorf("Response.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestResponse_ProtoMessage(t *testing.T) {
	type fields struct {
		Type  string
		Value *ChuckNorrisJoke
	}
	tests := []struct {
		name   string
		fields fields
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := &Response{
				Type:  tt.fields.Type,
				Value: tt.fields.Value,
			}
			r.ProtoMessage()
		})
	}
}

func TestResponse_Descriptor(t *testing.T) {
	type fields struct {
		Type  string
		Value *ChuckNorrisJoke
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
		want1  []int
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := &Response{
				Type:  tt.fields.Type,
				Value: tt.fields.Value,
			}
			got, got1 := r.Descriptor()
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Response.Descriptor() got = %v, want %v", got, tt.want)
			}
			if !reflect.DeepEqual(got1, tt.want1) {
				t.Errorf("Response.Descriptor() got1 = %v, want %v", got1, tt.want1)
			}
		})
	}
}

func TestResponse_GetType(t *testing.T) {
	type fields struct {
		Type  string
		Value *ChuckNorrisJoke
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &Response{
				Type:  tt.fields.Type,
				Value: tt.fields.Value,
			}
			if got := m.GetType(); got != tt.want {
				t.Errorf("Response.GetType() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestResponse_GetValue(t *testing.T) {
	type fields struct {
		Type  string
		Value *ChuckNorrisJoke
	}
	tests := []struct {
		name   string
		fields fields
		want   *ChuckNorrisJoke
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &Response{
				Type:  tt.fields.Type,
				Value: tt.fields.Value,
			}
			if got := m.GetValue(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Response.GetValue() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestChuckNorrisJoke_Reset(t *testing.T) {
	type fields struct {
		Id         uint32
		Joke       string
		Categories []string
	}
	tests := []struct {
		name   string
		fields fields
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &ChuckNorrisJoke{
				Id:         tt.fields.Id,
				Joke:       tt.fields.Joke,
				Categories: tt.fields.Categories,
			}
			m.Reset()
		})
	}
}

func TestChuckNorrisJoke_String(t *testing.T) {
	type fields struct {
		Id         uint32
		Joke       string
		Categories []string
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &ChuckNorrisJoke{
				Id:         tt.fields.Id,
				Joke:       tt.fields.Joke,
				Categories: tt.fields.Categories,
			}
			if got := m.String(); got != tt.want {
				t.Errorf("ChuckNorrisJoke.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestChuckNorrisJoke_ProtoMessage(t *testing.T) {
	type fields struct {
		Id         uint32
		Joke       string
		Categories []string
	}
	tests := []struct {
		name   string
		fields fields
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c := &ChuckNorrisJoke{
				Id:         tt.fields.Id,
				Joke:       tt.fields.Joke,
				Categories: tt.fields.Categories,
			}
			c.ProtoMessage()
		})
	}
}

func TestChuckNorrisJoke_Descriptor(t *testing.T) {
	type fields struct {
		Id         uint32
		Joke       string
		Categories []string
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
		want1  []int
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c := &ChuckNorrisJoke{
				Id:         tt.fields.Id,
				Joke:       tt.fields.Joke,
				Categories: tt.fields.Categories,
			}
			got, got1 := c.Descriptor()
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("ChuckNorrisJoke.Descriptor() got = %v, want %v", got, tt.want)
			}
			if !reflect.DeepEqual(got1, tt.want1) {
				t.Errorf("ChuckNorrisJoke.Descriptor() got1 = %v, want %v", got1, tt.want1)
			}
		})
	}
}

func TestChuckNorrisJoke_GetId(t *testing.T) {
	type fields struct {
		Id         uint32
		Joke       string
		Categories []string
	}
	tests := []struct {
		name   string
		fields fields
		want   uint32
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &ChuckNorrisJoke{
				Id:         tt.fields.Id,
				Joke:       tt.fields.Joke,
				Categories: tt.fields.Categories,
			}
			if got := m.GetId(); got != tt.want {
				t.Errorf("ChuckNorrisJoke.GetId() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestChuckNorrisJoke_GetJoke(t *testing.T) {
	type fields struct {
		Id         uint32
		Joke       string
		Categories []string
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &ChuckNorrisJoke{
				Id:         tt.fields.Id,
				Joke:       tt.fields.Joke,
				Categories: tt.fields.Categories,
			}
			if got := m.GetJoke(); got != tt.want {
				t.Errorf("ChuckNorrisJoke.GetJoke() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestChuckNorrisJoke_GetCategories(t *testing.T) {
	type fields struct {
		Id         uint32
		Joke       string
		Categories []string
	}
	tests := []struct {
		name   string
		fields fields
		want   []string
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &ChuckNorrisJoke{
				Id:         tt.fields.Id,
				Joke:       tt.fields.Joke,
				Categories: tt.fields.Categories,
			}
			if got := m.GetCategories(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("ChuckNorrisJoke.GetCategories() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_publisher_Publish(t *testing.T) {
	type fields struct {
		c     client.Client
		topic string
	}
	type args struct {
		ctx  context.Context
		msg  interface{}
		opts []client.PublishOption
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := &publisher{
				c:     tt.fields.c,
				topic: tt.fields.topic,
			}
			if err := p.Publish(tt.args.ctx, tt.args.msg, tt.args.opts...); (err != nil) != tt.wantErr {
				t.Errorf("publisher.Publish() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestNewPublisher(t *testing.T) {
	type args struct {
		topic string
		c     client.Client
	}
	tests := []struct {
		name string
		args args
		want Publisher
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := NewPublisher(tt.args.topic, tt.args.c); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewPublisher() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRegisterSubscriber(t *testing.T) {
	type args struct {
		topic string
		s     server.Server
		h     interface{}
		opts  []server.SubscriberOption
	}
	tests := []struct {
		name    string
		args    args
		wantErr bool
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if err := RegisterSubscriber(tt.args.topic, tt.args.s, tt.args.h, tt.args.opts...); (err != nil) != tt.wantErr {
				t.Errorf("RegisterSubscriber() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestNewJokeClient(t *testing.T) {
	type args struct {
		serviceName string
		c           client.Client
	}
	tests := []struct {
		name string
		args args
		want JokeClient
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := NewJokeClient(tt.args.serviceName, tt.args.c); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewJokeClient() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_jokeClient_ChuckNorris(t *testing.T) {
	type fields struct {
		c           client.Client
		serviceName string
	}
	type args struct {
		ctx  context.Context
		in   *Request
		opts []client.CallOption
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    *Response
		wantErr bool
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c := &jokeClient{
				c:           tt.fields.c,
				serviceName: tt.fields.serviceName,
			}
			got, err := c.ChuckNorris(tt.args.ctx, tt.args.in, tt.args.opts...)
			if (err != nil) != tt.wantErr {
				t.Errorf("jokeClient.ChuckNorris() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("jokeClient.ChuckNorris() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRegisterJokeHandler(t *testing.T) {
	type args struct {
		s    server.Server
		hdlr JokeHandler
		opts []server.HandlerOption
	}
	tests := []struct {
		name string
		args args
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			RegisterJokeHandler(tt.args.s, tt.args.hdlr, tt.args.opts...)
		})
	}
}

func TestJoke_ChuckNorris(t *testing.T) {
	type fields struct {
		JokeHandler JokeHandler
	}
	type args struct {
		ctx context.Context
		in  *Request
		out *Response
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			h := &Joke{
				JokeHandler: tt.fields.JokeHandler,
			}
			if err := h.ChuckNorris(tt.args.ctx, tt.args.in, tt.args.out); (err != nil) != tt.wantErr {
				t.Errorf("Joke.ChuckNorris() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}
